/*
Anrok API

# API reference  The Anrok API server is accessible at `https://api.anrok.com`.  All requests are HTTP POSTs with JSON in the body.  Authentication is via an HTTP header `Authorization: Bearer {apiKey}`.  The default rate limit for a seller account is 10 API requests per second. 

API version: 1.1
Contact: support@anrok.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)


// TransactionCustomerAddress The address where the product will be delivered or used. This address determines the taxing jurisdictions and rates for destination-based sourcing. For SaaS companies, this is typically the billing address. All address fields are optional: fields can be omitted or have null value, but empty strings are not allowed. Anrok will return an error if the address does not have enough information to determine the top-level taxing jurisdiction with high confidence.
type TransactionCustomerAddress struct {
	CustomerAddress *CustomerAddress
	CustomerLegacyUsOnlyAddress *CustomerLegacyUsOnlyAddress
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *TransactionCustomerAddress) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into CustomerAddress
	err = json.Unmarshal(data, &dst.CustomerAddress);
	if err == nil {
		jsonCustomerAddress, _ := json.Marshal(dst.CustomerAddress)
		if string(jsonCustomerAddress) == "{}" { // empty struct
			dst.CustomerAddress = nil
		} else {
			return nil // data stored in dst.CustomerAddress, return on the first match
		}
	} else {
		dst.CustomerAddress = nil
	}

	// try to unmarshal JSON data into CustomerLegacyUsOnlyAddress
	err = json.Unmarshal(data, &dst.CustomerLegacyUsOnlyAddress);
	if err == nil {
		jsonCustomerLegacyUsOnlyAddress, _ := json.Marshal(dst.CustomerLegacyUsOnlyAddress)
		if string(jsonCustomerLegacyUsOnlyAddress) == "{}" { // empty struct
			dst.CustomerLegacyUsOnlyAddress = nil
		} else {
			return nil // data stored in dst.CustomerLegacyUsOnlyAddress, return on the first match
		}
	} else {
		dst.CustomerLegacyUsOnlyAddress = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(TransactionCustomerAddress)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src TransactionCustomerAddress) MarshalJSON() ([]byte, error) {
	if src.CustomerAddress != nil {
		return json.Marshal(&src.CustomerAddress)
	}

	if src.CustomerLegacyUsOnlyAddress != nil {
		return json.Marshal(&src.CustomerLegacyUsOnlyAddress)
	}

	return nil, nil // no data in anyOf schemas
}


type NullableTransactionCustomerAddress struct {
	value *TransactionCustomerAddress
	isSet bool
}

func (v NullableTransactionCustomerAddress) Get() *TransactionCustomerAddress {
	return v.value
}

func (v *NullableTransactionCustomerAddress) Set(val *TransactionCustomerAddress) {
	v.value = val
	v.isSet = true
}

func (v NullableTransactionCustomerAddress) IsSet() bool {
	return v.isSet
}

func (v *NullableTransactionCustomerAddress) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTransactionCustomerAddress(val *TransactionCustomerAddress) *NullableTransactionCustomerAddress {
	return &NullableTransactionCustomerAddress{value: val, isSet: true}
}

func (v NullableTransactionCustomerAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTransactionCustomerAddress) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


