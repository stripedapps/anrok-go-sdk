/*
Anrok API

# API reference  The Anrok API server is accessible at “https://api.anrok.com”.  All requests are HTTP POSTs with JSON in the body.  Authentication is via an HTTP header “Authorization: Bearer {sellerId}/{apiKeyId}/secret.{apiKeySecret}”.  The default rate limit for a seller account is 10 API requests per second. 

API version: 1.0.0
Contact: support@anrok.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// CreateEphemeralTransactionCustomerAddress The address where the product will be delivered or used. This address determines the taxing jurisdictions and rates for destination-based sourcing. For SaaS companies, this is typically the billing address. All address fields are optional: fields can be omitted or have null value, but empty strings are not allowed. Anrok will return an error if the address does not have enough information to determine the top-level taxing jurisdiction with high confidence. International is a premium feature. Please contact support@anrok.com for more information.
type CreateEphemeralTransactionCustomerAddress struct {
	CustomerInternationalAddress *CustomerInternationalAddress
	CustomerUsAddress *CustomerUsAddress
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *CreateEphemeralTransactionCustomerAddress) UnmarshalJSON(data []byte) error {
	var err error
	// try to unmarshal JSON data into CustomerInternationalAddress
	err = json.Unmarshal(data, &dst.CustomerInternationalAddress);
	if err == nil {
		jsonCustomerInternationalAddress, _ := json.Marshal(dst.CustomerInternationalAddress)
		if string(jsonCustomerInternationalAddress) == "{}" { // empty struct
			dst.CustomerInternationalAddress = nil
		} else {
			return nil // data stored in dst.CustomerInternationalAddress, return on the first match
		}
	} else {
		dst.CustomerInternationalAddress = nil
	}

	// try to unmarshal JSON data into CustomerUsAddress
	err = json.Unmarshal(data, &dst.CustomerUsAddress);
	if err == nil {
		jsonCustomerUsAddress, _ := json.Marshal(dst.CustomerUsAddress)
		if string(jsonCustomerUsAddress) == "{}" { // empty struct
			dst.CustomerUsAddress = nil
		} else {
			return nil // data stored in dst.CustomerUsAddress, return on the first match
		}
	} else {
		dst.CustomerUsAddress = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(CreateEphemeralTransactionCustomerAddress)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *CreateEphemeralTransactionCustomerAddress) MarshalJSON() ([]byte, error) {
	if src.CustomerInternationalAddress != nil {
		return json.Marshal(&src.CustomerInternationalAddress)
	}

	if src.CustomerUsAddress != nil {
		return json.Marshal(&src.CustomerUsAddress)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableCreateEphemeralTransactionCustomerAddress struct {
	value *CreateEphemeralTransactionCustomerAddress
	isSet bool
}

func (v NullableCreateEphemeralTransactionCustomerAddress) Get() *CreateEphemeralTransactionCustomerAddress {
	return v.value
}

func (v *NullableCreateEphemeralTransactionCustomerAddress) Set(val *CreateEphemeralTransactionCustomerAddress) {
	v.value = val
	v.isSet = true
}

func (v NullableCreateEphemeralTransactionCustomerAddress) IsSet() bool {
	return v.isSet
}

func (v *NullableCreateEphemeralTransactionCustomerAddress) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCreateEphemeralTransactionCustomerAddress(val *CreateEphemeralTransactionCustomerAddress) *NullableCreateEphemeralTransactionCustomerAddress {
	return &NullableCreateEphemeralTransactionCustomerAddress{value: val, isSet: true}
}

func (v NullableCreateEphemeralTransactionCustomerAddress) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCreateEphemeralTransactionCustomerAddress) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


